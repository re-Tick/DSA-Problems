1. Problem: Coin Change Problem (gfg)
   Code:    long long int count(int arr[], int m, int n) {
                long long int dp[n+1];
                for(int i=0; i<=n ;i++){
                    dp[i] = 0;
                }
                dp[0] = 1;
                // Add 1 for each coin value in the 1-n dp
                for(int i=0; i<m ;i++){    
                    for(int j=1; j<=n ;j++){
                        if(arr[i] <= j)
                            dp[j] += dp[j-arr[i]]; 
                    }
                }
                return dp[n];
                // code here.
            }

2. Problem: KnapSack Problem
   Code:    int knapSack(int W, int wt[], int val[], int n)
            {
                int i, w;
                vector<vector<int>> K(n + 1, vector<int>(W + 1));
            
                // Build table K[][] in bottom up manner
                for(i = 0; i <= n; i++)
                {
                    for(w = 0; w <= W; w++)
                    {
                        if (i == 0 || w == 0)
                            K[i][w] = 0;
                        else if (wt[i - 1] <= w)
                            K[i][w] = max(val[i - 1] +
                                            K[i - 1][w - wt[i - 1]],
                                            K[i - 1][w]);
                        else
                            K[i][w] = K[i - 1][w];
                    }
                }
                return K[n][W];
            }        

3. Problem: nCr (combination problem gfg)
   Approach:nCr = (n-1)Cr + (n-1)C(r-1)
   Code:    // Returns value of Binomial Coefficient C(n, k)
            int binomialCoeffUtil(int n, int k, int** dp)
            {
                // If value in lookup table then return
                if (dp[n][k] != -1) //     
                    return dp[n][k];
            
                // store value in a table before return
                if (k == 0) {
                    dp[n][k] = 1;
                    return dp[n][k];
                }
                
                // store value in table before return
                if (k == n) {
                    dp[n][k] = 1; 
                    return dp[n][k];
                }
                
                // save value in lookup table before return
                dp[n][k] = binomialCoeffUtil(n - 1, k - 1, dp) +
                        binomialCoeffUtil(n - 1, k, dp);
                return dp[n][k];
            }

4. Problem: Permutation of n,r (gfg)
   Approach:P(n, k) = P(n-1, k) + k* P(n-1, k-1)   OR just get the product of n to n-k+1
   Code:    int PermutationCoeff(int n, int k)
            {
                int P = 1;
            
                // Compute n*(n-1)*(n-2)....(n-k+1)
                for (int i = 0; i < k; i++)
                    P *= (n-i) ;
            
                return P;
            }

5. Problem: Catalan Numbers (gfg)
   Approach:C0=1 and C{n+1}=sum( {i=0 to n} Ci*C{n-i} ) for n>=0 
   Similar problems -> a) Number of BST's for n nodes               = nth Catalan no
                       b) Number of unlabelled binary trees n nodes = nth Catalan no 
                       c) Number of ways for proper n parantheses   = nth Catalan no
                       d) Mountain Ranges (number of ways up-down without going below sea level)
                                                                    = nth Catalan no
                       e) Dyck Words (no of x >= no of y at any indx of string created cond X==Y)
                                                                    = nth Catalan no
                       f) Path on grid in which you can't go below(or above) diagonal 
                                                                    = nth Catalan no 
                       g) Connect Disjoint Chords (given n pairs of points and we have to find no ways to connect 
                       them without anyone intersecting)            = nth Catalan no
   Code:    unsigned long int catalanDP(unsigned int n)
            {
                // Table to store results of subproblems
                unsigned long int catalan[n + 1];
            
                // Initialize first two values in table
                catalan[0] = catalan[1] = 1;
            
                // Fill entries in catalan[] using recursive formula
                for (int i = 2; i <= n; i++) {
                    catalan[i] = 0;
                    for (int j = 0; j < i; j++)
                        catalan[i] += catalan[j] * catalan[i - j - 1]; //-1 is because computing for n+1 by using n
                }
            
                // Return last entry
                return catalan[n];
            }    

6. Problem: Matrix Chain Multiplication (gfg)
   Approach:dp[i][j] = min(dp[i][j], dp[i][k]+dp[k+1][j]+arr[i-1]*arr[k]*arr[j]) where k->(i to j-1)
   Code:    int matrixChainMemoised(int* p, int i, int j)
            {
                if (i == j)
                {
                    return 0;
                }
                if (dp[i][j] != -1)
                {
                    return dp[i][j];
                }
                dp[i][j] = INT_MAX;
                for (int k = i; k < j; k++)
                {
                    dp[i][j] = min(
                        dp[i][j], matrixChainMemoised(p, i, k)
                                + matrixChainMemoised(p, k + 1, j)
                                + p[i - 1] * p[k] * p[j]);
                }
                return dp[i][j];
            }

7. Problem: Edit Distance (gfg)
   Approach:1. If last characters of two strings are same, nothing much to do. Ignore last characters and get count for remaining strings. So we recur for lengths m-1 and n-1.
            2. Else (If last characters are not same), we consider all operations on ‘str1’, consider all three operations on last character of first string, recursively compute minimum cost for all three operations and take minimum of three values. 
               a.  Insert: Recur for m and n-1
               b.  Remove: Recur for m-1 and n
               c.  Replace: Recur for m-1 and n-1
   Code:    int editDistDP(string str1, string str2, int m, int n)
            {
                // Create a table to store results of subproblems
                int dp[m + 1][n + 1];
            
                // Fill d[][] in bottom up manner
                for (int i = 0; i <= m; i++) {
                    for (int j = 0; j <= n; j++) {
                        // If first string is empty, only option is to
                        // insert all characters of second string
                        if (i == 0)
                            dp[i][j] = j; // Min. operations = j
            
                        // If second string is empty, only option is to
                        // remove all characters of second string
                        else if (j == 0)
                            dp[i][j] = i; // Min. operations = i
            
                        // If last characters are same, ignore last char
                        // and recur for remaining string
                        else if (str1[i - 1] == str2[j - 1])
                            dp[i][j] = dp[i - 1][j - 1];
            
                        // If the last character is different, consider
                        // all possibilities and find the minimum
                        else
                            dp[i][j]
                                = 1
                                + min(dp[i][j - 1], // Insert
                                        dp[i - 1][j], // Remove
                                        dp[i - 1][j - 1]); // Replace
                    }
                }
            
                return dp[m][n];
            }